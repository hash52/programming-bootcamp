import { OneCompilerCodeBlock } from "@site/src/components/OneCompilerCodeBlock";

# メソッド

この章で得られるスキル：
- ✅ 処理をまとめて再利用可能にできる
- ✅ 引数と戻り値を使いこなせる
- ✅ コードの重複を減らし、読みやすいプログラムが書ける
- ✅ 実務でよく使うメソッドのパターンを理解できる

---

## Step 0: まず体験してみよう

説明の前に、まず **メソッドがないと何が困るのか** を体験しよう。

### シナリオ：SNSアプリの投稿機能を作りたい

あなたはSNSアプリを作っている。ユーザーの投稿を表示する機能を実装したい。

**仕様：**
- ユーザー名と投稿内容を表示
- いいね数を表示
- 投稿時刻を表示

**実行してみよう（メソッドなし）:**

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 投稿1を表示
        System.out.println("==================");
        System.out.println("【投稿】");
        System.out.println("投稿者: 太郎");
        System.out.println("内容: 今日はいい天気だ！");
        System.out.println("いいね: 12");
        System.out.println("時刻: 10:30");
        System.out.println("==================");

        // 投稿2を表示
        System.out.println("==================");
        System.out.println("【投稿】");
        System.out.println("投稿者: 花子");
        System.out.println("内容: ランチなう");
        System.out.println("いいね: 8");
        System.out.println("時刻: 12:15");
        System.out.println("==================");

        // 投稿3を表示
        System.out.println("==================");
        System.out.println("【投稿】");
        System.out.println("投稿者: 次郎");
        System.out.println("内容: 勉強中...");
        System.out.println("いいね: 5");
        System.out.println("時刻: 14:20");
        System.out.println("==================");

        // 100個の投稿を表示したら？
        // 同じコードを100回書く必要がある...
    }
}`}
/>

**問題点：**
- 同じパターンのコードを何度も書く必要がある
- 表示形式を変えたくなったら、全箇所を修正する必要がある
- コードが長く、読みにくい
- バグが混入しやすい

**では、メソッドを使うとどうなるか？**

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // わずか3行で完成！
        showPost("太郎", "今日はいい天気だ！", 12, "10:30");
        showPost("花子", "ランチなう", 8, "12:15");
        showPost("次郎", "勉強中...", 5, "14:20");

        // 表示形式を変えても、メソッド1箇所を直すだけ！
    }

    // 投稿を表示するメソッド
    public static void showPost(String author, String content, int likes, String time) {
        System.out.println("==================");
        System.out.println("【投稿】");
        System.out.println("投稿者: " + author);
        System.out.println("内容: " + content);
        System.out.println("いいね: " + likes);
        System.out.println("時刻: " + time);
        System.out.println("==================");
    }
}`}
/>

**解決できたこと：**
- ✅ 同じ処理を1箇所にまとめられた
- ✅ 表示形式の変更が1箇所で済む
- ✅ コードが短く読みやすくなった
- ✅ バグが減らせる

---

## Step 1: メソッドの基本を理解する

**メソッド** は、**処理をまとめて名前を付けたもの** である。
名前を呼び出すだけで、その処理を実行できる。

### メソッドの書き方

```java
public static 戻り値の型 メソッド名(引数) {
    // 処理
    return 戻り値;
}
```

### 各部分の意味

| 部分 | 意味 | 例 |
|------|------|-----|
| **public static** | 今は理解不要（おまじない） | `public static` |
| **戻り値の型** | 返す値の型（なければ`void`） | `int`, `String`, `void` |
| **メソッド名** | 処理の名前（動詞で始める） | `add`, `calculate`, `show` |
| **引数** | メソッドに渡す値 | `int a, int b` |
| **return** | 結果を返す（`void`なら不要） | `return a + b;` |

:::info public staticについて
`public static`は、今の段階では **「メソッドを定義するときに必要なおまじない」** と思っておけば良い。
この章では、 **戻り値の型、メソッド名、引数、returnの理解に集中** しよう。
`public`や`static`の詳しい意味は、第8章「複数クラスの連携」と第10章「オブジェクト指向の基礎」で学ぶ。
:::

### 最もシンプルなメソッド

**実行してみよう:**

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // メソッドを呼び出す
        sayHello();
        sayHello();
        sayHello();
    }

    // メソッドの定義
    public static void sayHello() {
        System.out.println("Hello!");
    }
}`}
/>

**やってみよう:**
- `sayHello()`の中身を変えてみよう（例：「こんにちは！」）
- `sayHello()`を10回呼び出してみよう

:::tip ポイント
メソッドを定義しても、**呼び出さないと実行されない**。
`main`メソッド内で呼び出すことで、初めて実行される。
:::

---

## Step 2: 引数の役割を理解する

**引数**（ひきすう）は、**メソッドに渡す値** である。
引数を使うことで、同じメソッドで異なる値に対応できる。

### 引数がないとどうなるか

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 引数がないと、名前ごとにメソッドが必要
        greetTaro();
        greetHanako();
        greetJiro();
        // 新しい人が増えるたびに、新しいメソッドを作る必要がある...
    }

    public static void greetTaro() {
        System.out.println("こんにちは、太郎さん");
    }

    public static void greetHanako() {
        System.out.println("こんにちは、花子さん");
    }

    public static void greetJiro() {
        System.out.println("こんにちは、次郎さん");
    }
}`}
/>

これでは、名前が増えるたびに新しいメソッドを作る必要がある。

### 引数が問題を解決

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 引数を使えば、1つのメソッドで様々な名前に対応できる
        greet("太郎");
        greet("花子");
        greet("次郎");
        greet("美咲");
        greet("健太");
        // 何人増えても、メソッドは1つでOK！
    }

    // 引数を受け取るメソッド
    public static void greet(String name) {
        System.out.println("こんにちは、" + name + "さん");
    }
}`}
/>

**やってみよう:**
- 自分の名前や好きな名前で`greet()`を呼び出してみよう

### 複数の引数

メソッドは、複数の引数を受け取ることができる。

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 複数の引数を渡す
        introduce("太郎", 25, "東京");
        introduce("花子", 22, "大阪");
        introduce("次郎", 30, "福岡");
    }

    // 複数の引数を受け取るメソッド
    public static void introduce(String name, int age, String city) {
        System.out.println("名前: " + name);
        System.out.println("年齢: " + age + "歳");
        System.out.println("出身: " + city);
        System.out.println("---");
    }
}`}
/>

**やってみよう:**
- 自分の情報で`introduce()`を呼び出してみよう

---

## Step 3: 戻り値の役割を理解する

**戻り値** は、**メソッドから返す値** である。
戻り値を使うことで、メソッドの計算結果を呼び出し元で使える。

### 戻り値がないとどうなるか

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 戻り値がないメソッド（void）
        addAndPrint(10, 20);
        addAndPrint(5, 15);

        // 問題：計算結果を再利用できない
        // 例えば、2つの計算結果を比較したり、さらに計算したりできない
    }

    // 戻り値がないメソッド：結果を表示するだけ
    public static void addAndPrint(int a, int b) {
        int sum = a + b;
        System.out.println(a + " + " + b + " = " + sum);
        // 結果を返せない
    }
}`}
/>

このように、戻り値がないと、計算結果を他の処理で使うことができない。

### 戻り値が問題を解決

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 戻り値を使えば、計算結果を受け取れる
        int result1 = add(10, 20);
        int result2 = add(5, 15);

        System.out.println("1つ目の計算結果: " + result1);
        System.out.println("2つ目の計算結果: " + result2);

        // 計算結果を再利用できる
        int total = result1 + result2;
        System.out.println("合計: " + total);

        // さらに別のメソッドに渡すこともできる
        int doubled = multiply(result1, 2);
        System.out.println(result1 + " の2倍: " + doubled);
    }

    // 戻り値があるメソッド：結果を返す
    public static int add(int a, int b) {
        return a + b;
    }

    public static int multiply(int a, int b) {
        return a * b;
    }
}`}
/>

**やってみよう:**
- `add()`の結果を3つ計算して、その合計を表示してみよう
- `multiply()`を使って、結果を3倍にしてみよう

### 処理の流れ

戻り値の処理の流れを理解しよう：

```
1. add(10, 20) が実行される
2. メソッド内で 10 + 20 が計算され、30 が返される（return される）
3. 返された 30 が変数 result に代入される
4. result を使って、他の処理ができる
```

:::tip ポイント
メソッドが値を`return`するのは、 **呼び出し元でその値を使えるようにするため** である。
変数で受け取らなくても良いが、受け取ることで結果を再利用できる。
:::

---

## Step 4: 実践例 - ゲームのダメージ計算

メソッドを使って、RPGゲームのダメージ計算を実装してみよう。

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // プレイヤーの攻撃
        System.out.println("【戦闘開始】");
        int damage1 = calculateDamage(50, 20, true);   // 攻撃力50, 防御力20, クリティカル
        System.out.println("プレイヤーの攻撃！ダメージ: " + damage1);

        int damage2 = calculateDamage(50, 20, false);  // 通常攻撃
        System.out.println("プレイヤーの攻撃！ダメージ: " + damage2);

        // 敵の攻撃
        int damage3 = calculateDamage(40, 30, false);
        System.out.println("敵の攻撃！ダメージ: " + damage3);

        // 合計ダメージ
        int totalDamage = damage1 + damage2 - damage3;
        System.out.println("---");
        System.out.println("HP差分: " + totalDamage);
    }

    /**
     * ダメージを計算する。
     *
     * @param attack 攻撃力
     * @param defense 防御力
     * @param isCritical クリティカルヒットかどうか
     * @return 計算されたダメージ
     */
    public static int calculateDamage(int attack, int defense, boolean isCritical) {
        int baseDamage = attack - defense;
        if (baseDamage < 0) {
            baseDamage = 0;  // ダメージは0未満にならない
        }

        if (isCritical) {
            baseDamage = baseDamage * 2;  // クリティカルは2倍
            System.out.println("  → クリティカルヒット！");
        }

        return baseDamage;
    }
}`}
/>

**このコードで学べること:**
- 複数の引数を使った計算
- `boolean`型の引数で条件分岐
- 戻り値を使った結果の再利用
- Javadocでメソッドの説明

**やってみよう:**
- 攻撃力と防御力を変えて、ダメージの変化を確認してみよう
- クリティカルの倍率を3倍に変えてみよう

---

## Step 5: スコープを理解する

**スコープ** とは、**変数が使える範囲** のことである。

### メソッド内の変数はメソッドの外からアクセスできない

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        int result = calculate(10, 5);
        System.out.println("結果: " + result);

        // ここではメソッド内の変数にアクセスできない
        // System.out.println(sum);  // エラー！sumはcalculateメソッド内でしか使えない
    }

    public static int calculate(int a, int b) {
        int sum = a + b;      // メソッド内のローカル変数
        int product = a * b;  // メソッド内のローカル変数
        System.out.println("calculate内部: sum = " + sum + ", product = " + product);
        return sum + product; // 計算結果を戻り値として返す
    }
}`}
/>

**やってみよう:**
- `main`メソッドで`sum`にアクセスしようとして、エラーを確認してみよう（コメントを外す）

:::tip ポイント
メソッド内の変数は外からアクセスできないので、戻り値で結果を返す。
これにより、メソッド同士が独立し、コードが整理される。
:::

---

## Step 6: オーバーロードを理解する

**オーバーロード** は、**同じ名前で異なる引数のメソッド** を定義することである。

### オーバーロードの条件

メソッドの識別は、以下で決まる：
- メソッド名
- **引数の数**
- **引数の型**

:::caution 重要
戻り値の型だけが異なるメソッドは、オーバーロードできない。
:::

**実行してみよう:**

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 引数が2つのint型
        int result1 = add(10, 20);
        System.out.println("add(10, 20) = " + result1);

        // 引数が2つのdouble型
        double result2 = add(10.5, 20.3);
        System.out.println("add(10.5, 20.3) = " + result2);

        // 引数が3つのint型
        int result3 = add(10, 20, 30);
        System.out.println("add(10, 20, 30) = " + result3);

        // 異なる引数パターンの挨拶
        greet("太郎");
        greet("山田", "太郎");
    }

    // int型の足し算（2つの引数）
    public static int add(int a, int b) {
        return a + b;
    }

    // double型の足し算（2つの引数）
    public static double add(double a, double b) {
        return a + b;
    }

    // int型の足し算（3つの引数）
    public static int add(int a, int b, int c) {
        return a + b + c;
    }

    // 挨拶（1つの引数）
    public static void greet(String name) {
        System.out.println("こんにちは、" + name + "さん");
    }

    // 挨拶（2つの引数）
    public static void greet(String lastName, String firstName) {
        System.out.println("こんにちは、" + lastName + " " + firstName + "さん");
    }
}`}
/>

**やってみよう:**
- 新しいオーバーロードを追加してみよう（例：4つの引数を足すメソッド）

---

## Step 7: Javadocでドキュメントを書く

**Javadoc** は、メソッドの説明を書くための標準的な方法である。

### Javadocの書き方

```java
/**
 * メソッドの説明。
 *
 * @param a 引数の説明
 * @param b 引数の説明
 * @return 戻り値の説明
 */
public static int add(int a, int b) {
    return a + b;
}
```

### Javadocのタグ

| タグ | 説明 | 例 |
|------|------|-----|
| `@param` | 引数の説明 | `@param name 名前` |
| `@return` | 戻り値の説明 | `@return 合計値` |
| `@throws` | 例外の説明 | `@throws IOException ファイルエラー` |

**実行してみよう:**

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        int sum = add(10, 20);
        System.out.println("合計: " + sum);

        double average = calculateAverage(80, 90, 75);
        System.out.println("平均: " + average);

        boolean isValid = isValidPassword("abc123");
        System.out.println("パスワード \"abc123\" は有効か: " + isValid);

        isValid = isValidPassword("SecurePass123");
        System.out.println("パスワード \"SecurePass123\" は有効か: " + isValid);
    }

    /**
     * 2つの整数を足す。
     *
     * @param a 1つ目の整数
     * @param b 2つ目の整数
     * @return aとbの合計
     */
    public static int add(int a, int b) {
        return a + b;
    }

    /**
     * 3つの整数の平均を計算する。
     *
     * @param num1 1つ目の数値
     * @param num2 2つ目の数値
     * @param num3 3つ目の数値
     * @return 3つの数値の平均
     */
    public static double calculateAverage(int num1, int num2, int num3) {
        return (num1 + num2 + num3) / 3.0;
    }

    /**
     * パスワードが有効かどうかを判定する。
     * パスワードは8文字以上である必要がある。
     *
     * @param password 検証するパスワード
     * @return パスワードが有効ならtrue、無効ならfalse
     */
    public static boolean isValidPassword(String password) {
        return password.length() >= 8;
    }
}`}
/>

**やってみよう:**
- 自分でメソッドを作成して、Javadocを書いてみよう

:::tip AI時代のドキュメント
現代のAI開発ツール（GitHub CopilotやChatGPTなど）は、Javadocを読んで適切なコードを生成する。
**良いドキュメントを書くことで、AIがより正確なコードを提案してくれる** ようになる。
ドキュメントを書く習慣は、AI時代においてますます重要になっている。
:::

---

## Step 8: 実践課題

これまで学んだことを組み合わせて、実践的なプログラムを作ってみよう。

### 課題1：温度変換プログラム

**仕様：**
- 摂氏（℃）を華氏（℉）に変換
- 華氏を摂氏に変換
- 公式：
  - ℉ = ℃ × 9/5 + 32
  - ℃ = (℉ - 32) × 5/9

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 摂氏を華氏に変換
        double fahrenheit = celsiusToFahrenheit(0);
        System.out.println("0℃ = " + fahrenheit + "℉");

        fahrenheit = celsiusToFahrenheit(100);
        System.out.println("100℃ = " + fahrenheit + "℉");

        // 華氏を摂氏に変換
        double celsius = fahrenheitToCelsius(32);
        System.out.println("32℉ = " + celsius + "℃");

        celsius = fahrenheitToCelsius(212);
        System.out.println("212℉ = " + celsius + "℃");
    }

    /**
     * 摂氏を華氏に変換する。
     *
     * @param celsius 摂氏温度
     * @return 華氏温度
     */
    public static double celsiusToFahrenheit(double celsius) {
        return celsius * 9 / 5 + 32;
    }

    /**
     * 華氏を摂氏に変換する。
     *
     * @param fahrenheit 華氏温度
     * @return 摂氏温度
     */
    public static double fahrenheitToCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5 / 9;
    }
}`}
/>

**やってみよう:**
- 20℃、25℃、30℃を華氏に変換してみよう

---

### 課題2：消費税計算プログラム

**仕様：**
- 税抜き価格から税込み価格を計算
- 税込み価格から税抜き価格を計算
- 消費税率は10%

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // 税抜き価格から税込み価格を計算
        int priceWithTax = addTax(1000);
        System.out.println("1000円（税抜） → " + priceWithTax + "円（税込）");

        priceWithTax = addTax(5000);
        System.out.println("5000円（税抜） → " + priceWithTax + "円（税込）");

        // 税込み価格から税抜き価格を計算
        int priceWithoutTax = removeTax(1100);
        System.out.println("1100円（税込） → " + priceWithoutTax + "円（税抜）");

        priceWithoutTax = removeTax(5500);
        System.out.println("5500円（税込） → " + priceWithoutTax + "円（税抜）");
    }

    /**
     * 税抜き価格から税込み価格を計算する（消費税10%）。
     *
     * @param price 税抜き価格
     * @return 税込み価格
     */
    public static int addTax(int price) {
        return (int) (price * 1.1);
    }

    /**
     * 税込み価格から税抜き価格を計算する（消費税10%）。
     *
     * @param priceWithTax 税込み価格
     * @return 税抜き価格
     */
    public static int removeTax(int priceWithTax) {
        return (int) (priceWithTax / 1.1);
    }
}`}
/>

**やってみよう:**
- 3000円、10000円の税込み価格を計算してみよう

---

### 課題3：BMI計算プログラム

**仕様：**
- 体重（kg）と身長（cm）からBMIを計算
- BMIの判定結果を返す
- BMI = 体重(kg) ÷ (身長(m) × 身長(m))

<OneCompilerCodeBlock
  language="java"
  code={`public class Main {
    public static void main(String[] args) {
        // BMIを計算
        double bmi1 = calculateBMI(65, 170);
        System.out.println("体重65kg、身長170cm → BMI: " + bmi1);
        System.out.println("判定: " + judgeBMI(bmi1));
        System.out.println();

        double bmi2 = calculateBMI(80, 170);
        System.out.println("体重80kg、身長170cm → BMI: " + bmi2);
        System.out.println("判定: " + judgeBMI(bmi2));
        System.out.println();

        double bmi3 = calculateBMI(50, 160);
        System.out.println("体重50kg、身長160cm → BMI: " + bmi3);
        System.out.println("判定: " + judgeBMI(bmi3));
    }

    /**
     * BMIを計算する。
     *
     * @param weight 体重（kg）
     * @param height 身長（cm）
     * @return BMI値
     */
    public static double calculateBMI(double weight, double height) {
        double heightInMeters = height / 100;  // cmをmに変換
        return weight / (heightInMeters * heightInMeters);
    }

    /**
     * BMI値から判定結果を返す。
     *
     * @param bmi BMI値
     * @return 判定結果
     */
    public static String judgeBMI(double bmi) {
        if (bmi < 18.5) {
            return "低体重";
        } else if (bmi < 25) {
            return "普通体重";
        } else if (bmi < 30) {
            return "肥満（1度）";
        } else {
            return "肥満（2度以上）";
        }
    }
}`}
/>

**やってみよう:**
- 自分の体重と身長でBMIを計算してみよう

---

## まとめ

この章では、Javaの **メソッド** について学んだ。

### 🎯 達成できたこと

- ✅ 処理をまとめて再利用可能にできるようになった
- ✅ 引数と戻り値を使いこなせるようになった
- ✅ コードの重複を減らし、読みやすいプログラムが書けるようになった
- ✅ 実務でよく使うメソッドのパターンを理解できた

### 📚 学んだ内容

| 概念 | 説明 | 例 |
|------|------|-----|
| **メソッド** | 処理をまとめたもの | `sayHello()` |
| **引数** | メソッドに渡す値 | `greet(String name)` |
| **戻り値** | メソッドから返す値 | `return a + b;` |
| **void** | 戻り値がないことを示す | `public static void show()` |
| **スコープ** | 変数が使える範囲 | メソッド内の変数は外から見えない |
| **オーバーロード** | 同じ名前で異なる引数 | `add(int, int)`, `add(double, double)` |
| **Javadoc** | メソッドの説明を書く | `@param`, `@return` |

### 🚀 次のステップ

次の章では、**複数クラスの連携** について学ぶ。
メソッドをさらに発展させ、クラスを分割してプログラムを整理する方法を学ぶ。

---

## 💡 よくある質問

### Q1: voidと戻り値あり、どっちを使えばいい？

**A:** 「結果を呼び出し元で使いたいか」で判断する。

- ✅ **戻り値あり**：計算結果を返したい、値を再利用したい → `int add(int a, int b)`
- ✅ **void**：表示するだけ、処理するだけ → `void showMessage(String msg)`

### Q2: メソッド名はどう付ければいい？

**A:** **動詞で始める** のが基本。処理内容が分かる名前にする。

- ✅ 良い例：`calculateTotal()`, `showResult()`, `isValid()`, `getUserName()`
- ❌ 悪い例：`method1()`, `doIt()`, `temp()`

### Q3: 引数が多すぎる場合はどうすればいい？

**A:** 引数が4つ以上になったら、以下を検討する：

1. **クラスにまとめる**（第10章で学ぶ）
2. **メソッドを分割する**
3. **本当に全部必要か見直す**

### Q4: メソッドはどれくらいの長さが適切？

**A:** 目安は **10〜20行程度**。長すぎる場合は、処理を分割することを検討する。

- ✅ 1つのメソッドは1つの役割
- ✅ 画面に収まる長さ（スクロール不要）

### Q5: public staticは今後も必ず書く必要がある？

**A:** 第10章（オブジェクト指向）以降は、 **`static`なしのメソッド** が主流になる。
今の段階では `public static` を書いておき、オブジェクト指向を学んだ後に違いを理解しよう。
